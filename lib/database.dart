// [File: database.dart]

import 'dart:ffi';
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';
import 'package:sqlite3/open.dart' as open;

part 'database.g.dart'; // Generated by build_runner

// --- Helper Class for Nested Categories ---
class CategoryWithSubcategories {
  final Category category; // The main category
  final List<Category> subcategories; // The list of its children

  CategoryWithSubcategories(this.category, this.subcategories);
}

// --- Table Definitions ---

// Category Table
@DataClassName('Category')
class Categories extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().withLength(min: 1, max: 100).unique()();
  DateTimeColumn get createdAt =>
      dateTime().withDefault(currentDateAndTime)();

  IntColumn get parentId => integer()
      .nullable()
      .references(Categories, #id, onDelete: KeyAction.setNull)();
}

// Transaction Table
@DataClassName('Transaction')
class Transactions extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get description => text().withLength(min: 1)();
  RealColumn get amount => real()();
  DateTimeColumn get dateOfFinance => dateTime()();
  DateTimeColumn get createdAt =>
      dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get modifiedAt =>
      dateTime().withDefault(currentDateAndTime)();
  IntColumn get categoryId =>
      integer().references(Categories, #id, onDelete: KeyAction.restrict)();
}

// --- Data Class for Joins ---
class TransactionWithCategoryAndParent {
  final Transaction transaction;
  final Category category;
  final Category? parentCategory;

  TransactionWithCategoryAndParent({
    required this.transaction,
    required this.category,
    this.parentCategory,
  });
}

// --- Database Class ---

@DriftDatabase(tables: [Categories, Transactions], daos: [CategoryDao, TransactionDao])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 5;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (m) async {
        await m.createAll();

        // --- NEW: Create the V2 category structure ---
        await batch((batch) async {
          // --- 1. Create INCOME Categories ---
          final incomeId = await into(categories).insert(
              CategoriesCompanion.insert(name: 'ðŸ’° Income'));
          batch.insertAll(categories, [
            CategoriesCompanion.insert(name: 'Salary / Allowance', parentId: Value(incomeId)),
            CategoriesCompanion.insert(name: 'Freelance / Side Income', parentId: Value(incomeId)),
            CategoriesCompanion.insert(name: 'Gifts / Refunds / Other', parentId: Value(incomeId)),
          ]);

          // --- 2. Create EXPENSE Categories ---
          // Essential Living
          final essentialId = await into(categories).insert(
              CategoriesCompanion.insert(name: 'ðŸ›’ Essential Living'));
          batch.insertAll(categories, [
            CategoriesCompanion.insert(name: 'Food & Groceries', parentId: Value(essentialId)),
            CategoriesCompanion.insert(name: 'Rent / Housing', parentId: Value(essentialId)),
            CategoriesCompanion.insert(name: 'Utilities (electricity, water, gas, internet, phone)', parentId: Value(essentialId)),
            CategoriesCompanion.insert(name: 'Transportation (fuel, public transport, ride-sharing)', parentId: Value(essentialId)),
            CategoriesCompanion.insert(name: 'Healthcare / Medicine', parentId: Value(essentialId)),
            CategoriesCompanion.insert(name: 'Insurance (health, life, vehicle)', parentId: Value(essentialId)),
          ]);

          // Personal & Lifestyle
          final personalId = await into(categories).insert(
              CategoriesCompanion.insert(name: 'â˜• Personal & Lifestyle'));
          batch.insertAll(categories, [
            CategoriesCompanion.insert(name: 'Eating Out / Coffee', parentId: Value(personalId)),
            CategoriesCompanion.insert(name: 'Clothing & Accessories', parentId: Value(personalId)),
            CategoriesCompanion.insert(name: 'Books / Education', parentId: Value(personalId)),
            CategoriesCompanion.insert(name: 'Subscriptions (Netflix, Spotify, etc.)', parentId: Value(personalId)),
            CategoriesCompanion.insert(name: 'Personal Care (salon, skincare, gym)', parentId: Value(personalId)),
          ]);

          // Leisure & Entertainment
          final leisureId = await into(categories).insert(
              CategoriesCompanion.insert(name: 'ðŸŽ® Leisure & Entertainment'));
          batch.insertAll(categories, [
            CategoriesCompanion.insert(name: 'Movies / Games / Events', parentId: Value(leisureId)),
            CategoriesCompanion.insert(name: 'Travel / Vacations', parentId: Value(leisureId)),
            CategoriesCompanion.insert(name: 'Hobbies (art supplies, instruments, etc.)', parentId: Value(leisureId)),
            CategoriesCompanion.insert(name: 'Gifts / Donations', parentId: Value(leisureId)),
          ]);

          // Finance & Obligations
          final financeId = await into(categories).insert(
              CategoriesCompanion.insert(name: 'ðŸ’¼ Finance & Obligations'));
          batch.insertAll(categories, [
            CategoriesCompanion.insert(name: 'Loan Payments / Debt', parentId: Value(financeId)),
            CategoriesCompanion.insert(name: 'Savings & Investments', parentId: Value(financeId)),
            CategoriesCompanion.insert(name: 'Taxes', parentId: Value(financeId)),
            CategoriesCompanion.insert(name: 'Bank Fees / Charges', parentId: Value(financeId)),
          ]);

          // Optional
          final optionalId = await into(categories).insert(
              CategoriesCompanion.insert(name: 'Optional (for more insight)'));
          batch.insertAll(categories, [
            CategoriesCompanion.insert(name: 'Emergency / Unexpected (repairs, fines, medical emergencies)', parentId: Value(optionalId)),
            CategoriesCompanion.insert(name: 'Pet Care', parentId: Value(optionalId)),
            CategoriesCompanion.insert(name: 'Home Improvement / Maintenance', parentId: Value(optionalId)),
          ]);
        });
      },
      onUpgrade: (m, from, to) async {
        if (from == 1) {
          await m.addColumn(categories, categories.parentId);
        }
      },
    );
  }
}

// --- DAOs (Data Access Objects) ---

@DriftAccessor(tables: [Categories])
class CategoryDao extends DatabaseAccessor<AppDatabase>
    with _$CategoryDaoMixin {
  CategoryDao(AppDatabase db) : super(db);

  Stream<List<Category>> watchCategories() => select(categories).watch();
  Future<List<Category>> getCategories() => select(categories).get();

  Future<Category> getIncomeMainCategory() {
    return (select(categories)..where((c) => c.name.equals('ðŸ’° Income'))).getSingle();
  }

  Future<Category?> getCategoryByName(String name) {
    return (select(categories)..where((c) => c.name.equals(name))).getSingleOrNull();
  }

  Stream<List<Category>> watchMainCategories() {
    return (select(categories)
      ..where((c) => c.parentId.isNull())
      ..orderBy([
            (c) => OrderingTerm(expression: c.name.equals('ðŸ’° Income').not()),
            (c) => OrderingTerm.asc(c.name)
      ]))
        .watch();
  }

  Stream<List<CategoryWithSubcategories>> watchCategoriesWithSubcategories() {
    return watchCategories().map((allCategories) {
      final mainCategories =
      allCategories.where((c) => c.parentId == null).toList();

      final subcategoriesMap = <int, List<Category>>{};
      for (final cat in allCategories) {
        if (cat.parentId != null) {
          subcategoriesMap.putIfAbsent(cat.parentId!, () => []).add(cat);
        }
      }

      return mainCategories.map((main) {
        return CategoryWithSubcategories(
          main,
          subcategoriesMap[main.id] ?? [],
        );
      }).toList();
    });
  }

  Future<int> addCategory(CategoriesCompanion entry) =>
      into(categories).insert(entry);
  Future<void> deleteCategory(int id) =>
      (delete(categories)..where((c) => c.id.equals(id))).go();

  Future<List<int>> getCategoryIdsForMain(Category mainCat) async {
    final allCategories = await getCategories();
    final subCategoryIds = allCategories
        .where((c) => c.parentId == mainCat.id)
        .map((c) => c.id)
        .toList();
    return [mainCat.id, ...subCategoryIds];
  }
}

@DriftAccessor(tables: [Transactions, Categories])
class TransactionDao extends DatabaseAccessor<AppDatabase>
    with _$TransactionDaoMixin {
  TransactionDao(AppDatabase db) : super(db);

  // --- MODIFIED: Added searchQuery parameter ---
  JoinedSelectStatement<HasResultSet, dynamic> _watchTransactionsQuery(
      DateTime month, {
        String? searchQuery,
      }) {
    final firstDay = DateTime(month.year, month.month, 1);
    final lastDay = DateTime(month.year, month.month + 1, 0)
        .add(const Duration(days: 1));

    final parentCategories = alias(categories, 'p');

    final query = select(transactions).join([
      innerJoin(
        categories,
        categories.id.equalsExp(transactions.categoryId),
      ),
      leftOuterJoin(
        parentCategories,
        parentCategories.id.equalsExp(categories.parentId),
      ),
    ]);

    query.where(transactions.dateOfFinance.isBetweenValues(firstDay, lastDay));

    // --- NEW: Add search filter ---
    if (searchQuery != null && searchQuery.isNotEmpty) {
      // This will search for the text anywhere in the description
      query.where(transactions.description.like('%$searchQuery%'));
    }

    query.orderBy([OrderingTerm.desc(transactions.dateOfFinance)]);
    return query;
  }

  List<TransactionWithCategoryAndParent> _mapRowsToTransactions(
      List<TypedResult> rows) {
    return rows.map((row) {
      return TransactionWithCategoryAndParent(
        transaction: row.readTable(transactions),
        category: row.readTable(categories),
        parentCategory: row.readTableOrNull(alias(categories, 'p')),
      );
    }).toList();
  }

  // --- MODIFIED: Added searchQuery parameter ---
  Stream<List<TransactionWithCategoryAndParent>> watchTransactionsInMonth(
      DateTime month, {
        String? searchQuery,
      }) {
    final query = _watchTransactionsQuery(month, searchQuery: searchQuery);
    return query.watch().map(_mapRowsToTransactions);
  }

  // --- MODIFIED: Added searchQuery parameter ---
  Stream<List<TransactionWithCategoryAndParent>>
  watchTransactionsInMonthForCategories(
      DateTime month,
      List<int> categoryIds, {
        String? searchQuery,
      }) {
    if (categoryIds.isEmpty) {
      return Stream.value([]);
    }
    final query = _watchTransactionsQuery(month, searchQuery: searchQuery);
    query.where(transactions.categoryId.isIn(categoryIds));
    return query.watch().map(_mapRowsToTransactions);
  }

  Future<int> addTransaction(TransactionsCompanion entry) {
    return into(transactions)
        .insert(entry.copyWith(modifiedAt: Value(DateTime.now())));
  }

  Future<bool> updateTransaction(TransactionsCompanion entry) {
    return update(transactions)
        .replace(entry.copyWith(modifiedAt: Value(DateTime.now())));
  }

  // --- MODIFIED: Added watchAllTransactions ---
  Stream<List<TransactionWithCategoryAndParent>> watchAllTransactions() {
    final parentCategories = alias(categories, 'p');
    return (select(transactions).join([
      innerJoin(categories, categories.id.equalsExp(transactions.categoryId)),
      leftOuterJoin(parentCategories,
          parentCategories.id.equalsExp(categories.parentId)),
    ])
      ..orderBy([OrderingTerm.desc(transactions.dateOfFinance)]))
        .watch()
        .map(_mapRowsToTransactions);
  }

  // --- MODIFIED: Added getAllTransactions ---
  Future<List<TransactionWithCategoryAndParent>> getAllTransactions() async {
    final parentCategories = alias(categories, 'p');
    final rows = await (select(transactions).join([
      innerJoin(categories, categories.id.equalsExp(transactions.categoryId)),
      leftOuterJoin(parentCategories,
          parentCategories.id.equalsExp(categories.parentId)),
    ])
      ..orderBy([OrderingTerm.desc(transactions.dateOfFinance)]))
        .get();
    
    return _mapRowsToTransactions(rows);
  }

  Future<void> deleteTransaction(int id) =>
      (delete(transactions)..where((t) => t.id.equals(id))).go();
}

// --- MODIFIED: Database file name changed ---
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'financier_v2.sqlite'));

    // Using NativeDatabase.createInBackground to run the database in a separate isolate
    return NativeDatabase.createInBackground(file);
  });
}